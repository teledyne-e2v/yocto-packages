From 4095348bfbe57b8dd6679edfe809b9bb03fd3407 Mon Sep 17 00:00:00 2001
From: Alejandro Flores <alejandro.flores@ridgerun.com>
Date: Wed, 9 Nov 2022 10:59:44 -0600
Subject: [PATCH] Squashed commit of the following:

commit 162dbaf025e0d65d3ba77cf3110852025fa35256
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Nov 8 14:08:11 2022 -0600

    Factor sum of variables in enum_framesizes loop

commit 376a321dc623f75e682b3355487bb09f6761d195
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Nov 8 13:54:05 2022 -0600

    Add warning for ROI heights above limit

commit ee746b4b7ce086e7033955a4d038db1ab4347208
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Nov 8 11:25:55 2022 -0600

    Add comment about SIMR enabling

commit fd5810ed9299e728886f9e04666e668f24a7c5f0
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Fri Nov 4 11:58:59 2022 -0600

    Add Single integration multiple ROI control support

commit fae3c0dcb632ab1315e85b248f55b00a069b982a
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Nov 2 17:02:28 2022 -0600

    Change roi1 width and height minimum values

commit 3394f4006fe5393e5fbe81616e76212c4d15df80
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 27 16:10:35 2022 -0600

    Add extra mode for ROI window size

commit e372558447d144b7bd661d95b1e27e153cec5241
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 27 13:52:46 2022 -0600

    Add basic ROI control support

commit fed92c8d466138cf2240dd32493ec32dff38781d
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Mon Oct 24 16:47:34 2022 -0600

    Add explanation on how frame sizes are listed

commit 15e560d8eca1b4a2de34eae62b23368355122db8
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 16:17:55 2022 -0600

    Add pointer guards

commit 5613b194404ca4d7c4c260dfd6e0ff171d1b79a0
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 15:52:19 2022 -0600

    Avoid overwriting ret value when updating controls range

commit a73fd979ee2d3907c2eed46dd42d388dec93f708
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 15:47:54 2022 -0600

    Add enum for custom control IDs

commit 8dfb725efb83d5e4b34cd7eb364a55e3eef1da18
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 15:37:34 2022 -0600

    Check for error codes different than 0 instead of less than 0

commit 973ee88e67d01735c6686067f9b80263b4a8ea8c
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 15:30:08 2022 -0600

    Add a more robust condition to list frame sizes

commit 8a9c59f359bd70e48bffe9caed6c5b06c43578a6
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 14:53:40 2022 -0600

    Remove unnecessary variables for updating control ranges

commit 020330e414e6f6a40beef0545057ca51e10ab7a5
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 14:43:27 2022 -0600

    Replace tabs for spaces on macro definitions

commit 8478023f9ebda7127dd37087aa2958a300b8118d
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 14:41:41 2022 -0600

    Fix typo on exposure factor explanation

commit 2ae9ba5152f5869a4799011faed424d5d0697e59
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 13:35:06 2022 -0600

    Set sub sampling limit to 32

commit acba56be6da9db26560d413cc111d9e6c864aa37
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 11:29:38 2022 -0600

    Remove unused ret variable

commit fdf96db9dd9150ef130222e46203fc19df13215e
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 20 11:28:44 2022 -0600

    Allow streaming odd resolutions

commit 6985bc1680ea9dfc175860b7a05c6c3dab34b1b8
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Mon Oct 17 17:27:26 2022 -0600

    Remove enum frame intervals

commit 20237f5615d8fc80aa8f1c84ae8940f39125ca50
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Mon Oct 17 17:17:00 2022 -0600

    Add condition to accept only integer resolutions

commit fa554d24ed27419667f3136a4a1a26b89f315335
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Mon Oct 17 17:05:00 2022 -0600

    Fix resolution mismatch issue

commit 09b1a5d8d955108b9c1d281433f22769f6d0a50f
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 13 16:34:52 2022 -0600

    Add menu to analog gain control

commit 3686187cb932b3df10d97b4be18030e36583148c
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 13 15:48:27 2022 -0600

    Add vertical sub sampling control support

commit 0b6c7345300f750482ee2f0b5140803e2df06997
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Oct 13 14:14:28 2022 -0600

    Add vertical sub sampling control support

commit cfcf69c377d788cfae2143716db84162497840d4
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Fri Oct 7 16:12:55 2022 -0600

    Modify controls range based on current mode

commit 7c5137d23da32896b5fb01e42932d1585dccdebd
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Oct 5 17:20:48 2022 -0600

    Remove lock from set format function

commit e59a39240784e5b71fd814f2f2a02c00dd644f26
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Oct 5 17:14:49 2022 -0600

    Add frame rate control support

commit eb34641079620739c9a8de664263a7077fd35f20
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Oct 5 10:47:14 2022 -0600

    Set controls before streaming

commit f2267282a5e32d84f637a49fb6fdf15b137444da
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Oct 5 10:43:53 2022 -0600

    Fix dev error calls arguments

commit 3c5d71732ea24f339e53f80825122b0496e1ae6f
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Oct 5 10:37:23 2022 -0600

    Add vertical and horizontal flip controls support

commit 6fdd7ee0045a162f6d94aaa2e160d4786b898a61
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Fri Sep 30 17:32:25 2022 -0600

    Fix exposure control conversion factors and implementation

commit d77bf766e4172f11cd3185d6d94cc04c3aa54e02
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Fri Sep 30 14:40:30 2022 -0600

    Remove unnecessary max and min control values check

commit a75f4c68dd0e2d827da726537437dd362699048c
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Fri Sep 30 14:36:45 2022 -0600

    Add exposure control support

commit 838c96a1bd59090238882c0502989ed5ffd064c6
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Sep 29 14:49:15 2022 -0600

    Remove debug function call from capture driver

commit 00855e5caaee57450a30970e7ad6aa5dd89684bc
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Sep 29 14:37:56 2022 -0600

    Add test pattern control support

commit c422d83085396f7b2f5c1695f4f0dd9208b86efd
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Sep 29 11:52:42 2022 -0600

    Add digital gain control support

commit 5420f5442b031b823a753b91387b7ec88d5a7cfb
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Sep 28 17:13:02 2022 -0600

    Add analogue gain control support

commit 1a687440c3180f941cc8d3392eb5d1fa4d0e124b
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Sep 15 12:08:09 2022 -0600

    Add controls support with dummy gain control

commit 3a226f8f351b7145e75d8ee3df37a0f043e02630
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Sep 7 14:35:22 2022 -0600

    Fix wrong table writing for 1920x800 modes

commit 7f5c26cc8d36d3dc0c166bf00325a0f4bfaa1a27
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Sep 7 11:58:53 2022 -0600

    Modify default mode set

commit b47eb8e78fcde0ff9b533f451ed982a9a7214a61
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Sep 7 11:54:03 2022 -0600

    Add 1920x800 resolution for raw8 and raw10 formats

commit cb81025aced9292f1df323bf92dffd3f0d3c93e9
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Aug 31 17:17:52 2022 -0600

    Remove driver enable from defconfig file

commit 952a2e9c0380867c058c2f7bc29aa3e809f03478
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Aug 31 11:10:51 2022 -0600

    Add braces to if statements

commit 5ca45ace9870f3676a397565cc55328f727ce101
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Aug 31 11:00:37 2022 -0600

    Fix indentation by using spaces on macros

commit fd03a3051471a5debcbb9d7a8168d838eea07210
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 18:01:52 2022 -0600

    Remove modification of build time

commit 05fe025515d7e46fadebf8e331e8f8f0a7ff6cdf
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 17:57:27 2022 -0600

    Remove unnecessary comment from dtsi

commit 80d24cd2280a28b4abd4719af1e61525f4989141
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 15:12:52 2022 -0600

    Fix indentation on standy reg value

commit 26c331d8811067184610740ca5cd02522874fa42
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 15:02:56 2022 -0600

    Update register tables values

commit 9645ed0ee63ad025eea28027572c5a438467cdb3
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 14:13:11 2022 -0600

    Remove registers from mode tables that where overwriting pixel timing values

commit 25a8dedbd731329e47940aebc8b12d6116c4c612
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Aug 30 14:12:06 2022 -0600

    Fix set framesize and frameinterval for each mode

commit 22d1f9c9916c7ec2b7b9d6ca85641495758d967e
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Aug 25 16:58:17 2022 -0600

    Swap assignments position on table write

commit 81d0710ec9b5d36d561ab7d1293e5a67af8a99ab
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Aug 25 16:51:55 2022 -0600

    fix kconfig indentation

commit 0c1d6389238de1e91fbc554e9462ff173a31cbc6
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Thu Aug 25 16:38:13 2022 -0600

    Fix indentation and remove comments from dtsi

commit 2a5fcca4bb7500e2a08300fc76eb33e4c7fd3a3e
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Aug 24 12:08:15 2022 -0600

    Use Lindent tool to indent code

commit 83facf865e4c68fa15bbb45affe7734cb57fc5e8
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Jul 12 17:43:05 2022 -0600

    Modify driver and kernel files for topaz2m sensor support

commit 9a74a9897a588ee5c60a9f33f8c02bb151279240
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Wed Jul 20 15:06:35 2022 -0600

    Modify kernel build timestamp

commit 41c51de1e432d672e15dfd7877ba5226a2dc5eec
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Jul 12 14:00:20 2022 -0600

    Add driver contents based on imx327 driver

commit 94f7f5e4710c783030441ab73478d97132bdad92
Author: Alejandro Flores <alejandro.flores@ridgerun.com>
Date:   Tue Jun 28 18:11:23 2022 -0600

    Add base driver files
---
 .../boot/dts/freescale/imx8mm-verdin.dtsi     |   61 +
 drivers/media/i2c/Kconfig                     |   10 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/teledyne-topaz2m.c          | 1508 +++++++++++++++++
 drivers/media/i2c/teledyne-topaz2m.h          |  621 +++++++
 .../media/platform/mxc/capture/mx6s_capture.c |  108 +-
 .../media/platform/mxc/capture/mxc_mipi_csi.c |   41 +-
 drivers/media/v4l2-core/v4l2-ctrls.c          |   12 +
 include/uapi/linux/v4l2-controls.h            |   15 +-
 9 files changed, 2349 insertions(+), 28 deletions(-)
 create mode 100644 drivers/media/i2c/teledyne-topaz2m.c
 create mode 100644 drivers/media/i2c/teledyne-topaz2m.h

diff --git a/arch/arm64/boot/dts/freescale/imx8mm-verdin.dtsi b/arch/arm64/boot/dts/freescale/imx8mm-verdin.dtsi
index eb9cf2576..b05afce66 100755
--- a/arch/arm64/boot/dts/freescale/imx8mm-verdin.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mm-verdin.dtsi
@@ -551,6 +551,30 @@
 	pinctrl-1 = <&pinctrl_i2c3_gpio>;
 	scl-gpios = <&gpio5 18 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
 	sda-gpios = <&gpio5 19 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+
+	topaz2m: topaz2m@10 {
+		compatible = "teledyne,topaz2m";
+		reg = <0x10>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio5>;
+		pwdn-gpio = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		csi_id = <0>;
+		mclk = <24000000>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				status = "okay";
+				topaz2m_port: endpoint {
+					remote-endpoint = <&mipi1_sensor_ep>;
+					data-lanes = <1 2>;
+					clock-lanes = <0>;
+				};
+			};
+		};
+	};
 };
 
 /* Verdin I2C_1 */
@@ -641,6 +665,43 @@
 	};
 };
 
+&mipi_csi_1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0{
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+			csi1_mipi_ep: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&csi1_ep>;
+			};
+
+			mipi1_sensor_ep: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&topaz2m_port>;
+				data-lanes = <2>;
+				csis-wclk;
+			};
+		};
+	};
+};
+
+&csi1_bridge {
+	fsl,mipi-mode;
+	status = "okay";
+	port {
+		csi1_ep: endpoint {
+			remote-endpoint = <&csi1_mipi_ep>;
+		};
+	};
+};
+
 &mu {
 	status = "okay";
 };
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index fcffcc31d..ea03643d9 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -566,6 +566,16 @@ config VIDEO_APTINA_PLL
 config VIDEO_SMIAPP_PLL
 	tristate
 
+config VIDEO_TELEDYNE_TOPAZ2M
+	tristate "Topaz 2M CMOS sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor driver for the
+	  Teledyne Topaz 2M CMOS image sensor.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called teledyne-topaz2m.
+
 config VIDEO_IMX214
 	tristate "Sony IMX214 sensor support"
 	depends on GPIOLIB && I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index beb170b00..b0b7d445a 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -115,5 +115,6 @@ obj-$(CONFIG_VIDEO_IMX274)	+= imx274.o
 obj-$(CONFIG_VIDEO_IMX319)	+= imx319.o
 obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
+obj-$(CONFIG_VIDEO_TELEDYNE_TOPAZ2M) += teledyne-topaz2m.o
 
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
diff --git a/drivers/media/i2c/teledyne-topaz2m.c b/drivers/media/i2c/teledyne-topaz2m.c
new file mode 100644
index 000000000..b1e7ca20e
--- /dev/null
+++ b/drivers/media/i2c/teledyne-topaz2m.c
@@ -0,0 +1,1508 @@
+/*
+ * teledyne-topaz2m.c - topaz2m sensor driver
+ *
+ * Copyright (c) 2022, RidgeRun, LLC.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/regmap.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+#include "teledyne-topaz2m.h"
+
+#define TOPAZ2M_MODEL_ID_ADDR  0x7F
+#define TOPAZ2M_MODEL_ID_VAL   0x8036
+
+#define TOPAZ2M_STANDBY_REG_ADDR      0x02
+#define TOPAZ2M_ACQUISITION_MODE_VAL  0x0008
+#define TOPAZ2M_STANDBY_MODE_VAL      0x0001
+
+#define TOPAZ2M_TIMING_RAM_INIT_ADDR  0x4F
+
+#define TOPAZ2M_DEFAULT_MODE 0
+
+#define TOPAZ2M_ANA_GAIN_ADDR    0x0D
+#define TOPAZ2M_ANA_GAIN_MIN     0
+#define TOPAZ2M_ANA_GAIN_DEF     TOPAZ2M_ANA_GAIN_MIN
+#define TOPAZ2M_ANA_GAIN_STEP    1
+
+#define TOPAZ2M_DIG_GAIN_ADDR   0x0E
+#define TOPAZ2M_DIG_GAIN_MIN    1
+#define TOPAZ2M_DIG_GAIN_MAX    4096
+#define TOPAZ2M_DIG_GAIN_DEF    256
+#define TOPAZ2M_DIG_GAIN_STEP   1
+
+#define TOPAZ2M_TEST_PATTERN_ADDR   0x04
+#define TOPAZ2M_TEST_PATTERN_MIN    0
+#define TOPAZ2M_TEST_PATTERN_DEF    TOPAZ2M_TEST_PATTERN_MIN
+
+#define TOPAZ2M_EXPOSURE_COARSE_TIME_ADDR   0x0B
+#define TOPAZ2M_EXPOSURE_FINE_TIME_ADDR     0x0C
+#define TOPAZ2M_FRAME_RATE_PERIOD_ADDR      0x07
+#define TOPAZ2M_LINE_LENGTH_ADDR            0x06
+
+/* The exposure conversion factor is calculated as
+ * a conversion factor from microseconds (us) to
+ * nanoseconds (ns) divided by a clock period
+ * of 20 ns (for a 50MHz clk)
+ * (1000 ns/us) / (20 ns) = 50
+ */
+#define TOPAZ2M_EXPOSURE_CONV_FACTOR    50
+
+/* Exposure time values in microseconds (us) */
+#define TOPAZ2M_EXPOSURE_TIME_MIN                   1
+#define TOPAZ2M_EXPOSURE_TIME_MAX                   500000
+#define TOPAZ2M_EXPOSURE_TIME_RAW8_1920X800_DEF     6800
+#define TOPAZ2M_EXPOSURE_TIME_RAW8_1920X1080_DEF    9180
+#define TOPAZ2M_EXPOSURE_TIME_RAW10_1920X800_DEF    10400
+#define TOPAZ2M_EXPOSURE_TIME_RAW10_1920X1080_DEF   14040
+#define TOPAZ2M_EXPOSURE_TIME_STEP                  1
+
+#define TOPAZ2M_ROI1_ADDR   0x13
+#define TOPAZ2M_FLIP_MIN    0
+#define TOPAZ2M_FLIP_MAX    1
+#define TOPAZ2M_FLIP_DEF    TOPAZ2M_FLIP_MIN
+#define TOPAZ2M_FLIP_STEP   1
+#define TOPAZ2M_HFLIP_SHIFT 1
+#define TOPAZ2M_VFLIP_SHIFT 0
+
+#define TOPAZ2M_FRAME_RATE_MIN                  5
+#define TOPAZ2M_FRAME_RATE_RAW8_1920X800_MAX    130
+#define TOPAZ2M_FRAME_RATE_RAW8_1920X1080_MAX   100
+#define TOPAZ2M_FRAME_RATE_RAW10_1920X800_MAX   80
+#define TOPAZ2M_FRAME_RATE_RAW10_1920X1080_MAX  65
+#define TOPAZ2M_FRAME_RATE_RAW8_1920X800_DEF    TOPAZ2M_FRAME_RATE_RAW8_1920X800_MAX
+#define TOPAZ2M_FRAME_RATE_RAW8_1920X1080_DEF   TOPAZ2M_FRAME_RATE_RAW8_1920X1080_MAX
+#define TOPAZ2M_FRAME_RATE_RAW10_1920X800_DEF   TOPAZ2M_FRAME_RATE_RAW10_1920X800_MAX
+#define TOPAZ2M_FRAME_RATE_RAW10_1920X1080_DEF  TOPAZ2M_FRAME_RATE_RAW10_1920X1080_MAX
+#define TOPAZ2M_FRAME_RATE_STEP                 1
+#define TOPAZ2M_MASTER_CLK_FREQ_HZ              50000000
+
+#define TOPAZ2M_ROI_WIDTH_ADDR         0x10
+#define TOPAZ2M_ROI_OFFSET_COL_ADDR    0x12
+#define TOPAZ2M_ROI_WIDTH_MIN          64
+#define TOPAZ2M_ROI_WIDTH_MAX          1920
+#define TOPAZ2M_ROI_WIDTH_DEF          TOPAZ2M_ROI_WIDTH_MAX
+#define TOPAZ2M_ROI_WIDTH_STEP         2
+#define TOPAZ2M_ROI_OFFSET_COL_MIN     0
+#define TOPAZ2M_ROI_OFFSET_COL_MAX     1920
+#define TOPAZ2M_ROI_OFFSET_COL_DEF     TOPAZ2M_ROI_OFFSET_COL_MIN
+#define TOPAZ2M_ROI_OFFSET_STEP        1
+
+#define TOPAZ2M_ROI1_HEIGHT_ADDR        0x0F
+#define TOPAZ2M_ROI1_OFFSET_ROW_ADDR    0x11
+#define TOPAZ2M_ROI1_HEIGHT_MIN         32
+#define TOPAZ2M_ROI1_HEIGHT_MAX         1080
+#define TOPAZ2M_ROI1_HEIGHT_DEF         TOPAZ2M_ROI1_HEIGHT_MAX
+#define TOPAZ2M_ROI1_HEIGHT_STEP        2
+#define TOPAZ2M_ROI1_OFFSET_ROW_MIN     0
+#define TOPAZ2M_ROI1_OFFSET_ROW_MAX     1080
+#define TOPAZ2M_ROI1_OFFSET_ROW_DEF     TOPAZ2M_ROI1_OFFSET_ROW_MIN
+
+#define TOPAZ2M_SIMR_ENABLE_ADDR        0x03
+#define TOPAZ2M_SIMR_ENABLE_SHIFT       7
+#define TOPAZ2M_ROI2_HEIGHT_ADDR        0x18
+#define TOPAZ2M_ROI2_OFFSET_ROW_ADDR    0x19
+#define TOPAZ2M_ROI2_HEIGHT_MIN         0
+#define TOPAZ2M_ROI2_HEIGHT_MAX         1080
+#define TOPAZ2M_ROI2_HEIGHT_DEF         TOPAZ2M_ROI2_HEIGHT_MIN
+#define TOPAZ2M_ROI2_HEIGHT_STEP        2
+#define TOPAZ2M_ROI2_OFFSET_ROW_MIN     0
+#define TOPAZ2M_ROI2_OFFSET_ROW_MAX     1080
+#define TOPAZ2M_ROI2_OFFSET_ROW_DEF     TOPAZ2M_ROI2_OFFSET_ROW_MIN
+
+#define TOPAZ2M_SUB_SAMPLING_MASK       7
+#define TOPAZ2M_H_SUB_SAMPLING_SHIFT    5
+#define TOPAZ2M_V_SUB_SAMPLING_SHIFT    2
+#define TOPAZ2M_SUB_SAMPLING_MIN      0
+#define TOPAZ2M_SUB_SAMPLING_DEF      TOPAZ2M_SUB_SAMPLING_MIN
+#define TOPAZ2M_SUB_SAMPLING_DEF_NUM  1
+
+#define TOPAZ2_NUM_CTRLS_HINT 5
+
+static const char *const 
+	topaz2m_analog_gain_ops[] = {
+	"1.00 (0.00 dB)",
+	"1.20 (1.58 dB)",
+	"1.45 (3.23 dB)",
+	"1.71 (4.66 dB)",
+	"2.00 (6.02 dB)",
+	"2.40 (7.60 dB)",
+	"3.00 (9.54 dB)",
+	"3.43 (10.71 dB)",
+	"4.00 (12.04 dB)",
+	"4.80 (13.62 dB)",
+	"6.00 (15.56 dB)",
+	"6.86 (16.73 dB)",
+	"8.00 (18.06 dB)",
+	"9.60 (19.65 dB)",
+	"12.00 (21.58 dB)",
+	"16.00 (24.08 dB)",
+};
+
+static const char *const 
+	topaz2m_test_pattern_ops[] = {
+	"Disabled",
+	"Front pattern",
+	"Rear pattern",
+};
+
+static const char *const 
+	topaz2m_sub_sampling_ops[] = {
+	"No sub sampling",
+	"Sub sampling 2",
+	"Sub sampling 4",
+	"Sub sampling 8",
+	"Sub sampling 16",
+	"Sub sampling 32",
+};
+
+enum topaz2m_mode_id {
+	TOPAZ2M_MODE_RAW8_1920X800 = 0,
+	TOPAZ2M_MODE_RAW8_1920X1080,
+	TOPAZ2M_MODE_RAW8_ROI1,
+	TOPAZ2M_MODE_RAW8_ROI2,
+	TOPAZ2M_MODE_RAW10_1920X800,
+	TOPAZ2M_MODE_RAW10_1920X1080,
+	TOPAZ2M_MODE_RAW10_ROI1,
+	TOPAZ2M_MODE_RAW10_ROI2,
+	TOPAZ2M_NUM_MODES,
+};
+
+enum topaz2m_format_id {
+	TOPAZ2M_FORMAT_RAW8 = 0,
+	TOPAZ2M_FORMAT_RAW10,
+	TOPAZ2M_NUM_FORMATS,
+};
+
+enum topaz2m_framesize_id {
+	TOPAZ2M_FRAMESIZE_1920X800 = 0,
+	TOPAZ2M_FRAMESIZE_1920X1080,
+	TOPAZ2M_FRAMESIZE_ROI1,
+	TOPAZ2M_FRAMESIZE_ROI2,
+	TOPAZ2M_NUM_FRAMESIZES,
+};
+
+struct topaz2m_mode_info {
+	enum topaz2m_mode_id id;
+	u32 fmt_code;
+	enum v4l2_colorspace colorspace;
+	u32 width;
+	u32 height;
+	u8 frameinterval;
+};
+
+/* Modes with the same pixel format must be listed consecutively */
+static const struct
+topaz2m_mode_info topaz2m_modes[TOPAZ2M_NUM_MODES] = {
+	{ TOPAZ2M_MODE_RAW8_1920X800, MEDIA_BUS_FMT_Y8_1X8,
+	 V4L2_COLORSPACE_SRGB, 1920, 800, 130 },
+	{ TOPAZ2M_MODE_RAW8_1920X1080, MEDIA_BUS_FMT_Y8_1X8,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 100 },
+	{ TOPAZ2M_MODE_RAW8_ROI1, MEDIA_BUS_FMT_Y8_1X8,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 100 },
+	{ TOPAZ2M_MODE_RAW8_ROI2, MEDIA_BUS_FMT_Y8_1X8,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 100 },
+	{ TOPAZ2M_MODE_RAW10_1920X800, MEDIA_BUS_FMT_Y10_1X10,
+	 V4L2_COLORSPACE_SRGB, 1920, 800, 80 },
+	{ TOPAZ2M_MODE_RAW10_1920X1080, MEDIA_BUS_FMT_Y10_1X10,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 65 },
+	{ TOPAZ2M_MODE_RAW10_ROI1, MEDIA_BUS_FMT_Y10_1X10,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 65 },
+	{ TOPAZ2M_MODE_RAW10_ROI2, MEDIA_BUS_FMT_Y10_1X10,
+	 V4L2_COLORSPACE_SRGB, 1920, 1080, 65 }
+};
+
+struct topaz2m_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *ana_gain;
+	struct v4l2_ctrl *dig_gain;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *frame_rate;
+	struct v4l2_ctrl *roi_width;
+	struct v4l2_ctrl *roi_offset_col;
+	struct v4l2_ctrl *roi1_height;
+	struct v4l2_ctrl *roi2_height;
+	struct v4l2_ctrl *roi1_offset_row;
+	struct v4l2_ctrl *roi2_offset_row;
+	struct v4l2_ctrl *h_sub_sampling;
+	struct v4l2_ctrl *v_sub_sampling;
+	struct v4l2_ctrl *test_pattern;
+};
+
+struct topaz2m {
+	struct v4l2_subdev subdev;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct topaz2m_ctrls ctrls;
+
+	bool on;
+	int csi;
+	int pwdn_gpio;
+
+	int roi_width;
+	int roi1_height;
+	int roi2_height;
+	bool roi1_enable;
+	bool roi2_enable;
+
+	int h_sub_sampling_num;
+	int v_sub_sampling_num;
+
+	struct mutex lock;
+	const struct topaz2m_mode_info *current_mode;
+	struct v4l2_mbus_framefmt fmt;
+	bool streaming;
+
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static inline int topaz2m_read_reg(struct topaz2m *sensor, u8 addr,
+				   unsigned int *val);
+
+static inline int topaz2m_write_reg(struct topaz2m *sensor, u8 addr, u16 val);
+
+static inline int
+topaz2m_write_table(struct topaz2m *sensor, topaz2m_reg * mode_table,
+		    s32 array_size);
+
+static inline int
+topaz2m_write_pixel_timing_table(struct topaz2m *sensor,
+				 topaz2m_reg * mode_table, s32 array_size);
+
+static int topaz2m_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id);
+
+static int topaz2m_remove(struct i2c_client *client);
+
+static int topaz2m_init_controls(struct topaz2m *sensor);
+
+static int topaz2m_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static int topaz2m_set_analog_gain(struct topaz2m *sensor, s32 value);
+
+static int topaz2m_set_digital_gain(struct topaz2m *sensor, s32 value);
+
+static int topaz2m_set_exposure(struct topaz2m *sensor, s32 value);
+
+static int topaz2m_set_flip(struct topaz2m *sensor, s32 do_flip, int shift);
+
+static int topaz2m_set_frame_rate(struct topaz2m *sensor, s32 value);
+
+static int topaz2m_set_test_pattern(struct topaz2m *sensor, s32 value);
+
+static int topaz2m_set_sub_sampling(struct topaz2m *sensor, s32 value, int shift);
+
+static int topaz2m_set_roi_offset(struct topaz2m *sensor, s32 value, u8 offset_addr);
+
+static int topaz2m_set_roi_size(struct topaz2m *sensor, s32 value, u8 size_addr);
+
+static const struct v4l2_ctrl_ops topaz2m_ctrl_ops = {
+	.s_ctrl = topaz2m_s_ctrl,
+};
+
+static inline struct topaz2m *to_topaz2m(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct topaz2m, subdev);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct topaz2m,
+				ctrls.handler)->subdev;
+}
+
+static inline struct topaz2m *sd_to_topaz2m(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct topaz2m, subdev);
+}
+
+static int topaz2m_power_on(struct topaz2m *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int err = 0;
+
+	if (sensor->pwdn_gpio < 0) {
+		return -EIO;
+	}
+
+	gpio_set_value(sensor->pwdn_gpio, 1);
+
+	if (err) {
+		dev_err(&client->dev, "Failed to power on device");
+		sensor->on = false;
+		return -EIO;
+	}
+
+	sensor->on = true;
+
+	return err;
+}
+
+static int topaz2m_power_off(struct topaz2m *sensor)
+{
+
+	struct i2c_client *client = sensor->i2c_client;
+	int err = 0;
+
+	if (sensor->pwdn_gpio < 0) {
+		return -EIO;
+	}
+
+	gpio_set_value(sensor->pwdn_gpio, 0);
+
+	if (err) {
+		dev_err(&client->dev, "Failed to power off device");
+		return -EIO;
+	}
+
+	sensor->streaming = false;
+	sensor->on = false;
+
+	return 0;
+}
+
+static int topaz2m_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct topaz2m *sensor = to_topaz2m(client);
+
+	if (on && !sensor->on) {
+		topaz2m_power_on(sensor);
+	} else if (!on && sensor->on) {
+		topaz2m_power_off(sensor);
+	}
+
+	return 0;
+}
+
+static inline int topaz2m_read_reg(struct topaz2m *sensor, u8 addr,
+				   unsigned int *val)
+{
+	return regmap_read(sensor->regmap, addr, (unsigned int *)val);
+}
+
+static inline int topaz2m_write_reg(struct topaz2m *sensor, u8 addr, u16 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int err = 0;
+
+	err = regmap_write(sensor->regmap, addr, val);
+	if (err) {
+		dev_err(&client->dev, "I2C write failed, %x = %x", addr, val);
+	}
+	return err;
+}
+
+static int
+topaz2m_write_table(struct topaz2m *sensor, topaz2m_reg * mode_table,
+		    s32 array_size)
+{
+	register u8 reg_addr = 0;
+	register u16 val = 0;
+	int i, ret = 0;
+	register u32 delay_ms = 0;
+
+	for (i = 0; i < array_size; ++i, ++mode_table) {
+		reg_addr = mode_table->reg_addr;
+		val = mode_table->val;
+		delay_ms = mode_table->delay_ms;
+		ret = topaz2m_write_reg(sensor, reg_addr, val);
+
+		if (ret != 0) {
+			goto err;
+		}
+
+		if (delay_ms) {
+			msleep(delay_ms);
+		}
+	}
+
+err:
+	return ret;
+}
+
+static int
+topaz2m_write_pixel_timing_table(struct topaz2m *sensor,
+				 topaz2m_reg * mode_table, s32 array_size)
+{
+	register u8 reg_addr = 0;
+	register u16 val = 0;
+	int i, ret = 0;
+	register u32 delay_ms = 0;
+
+	for (i = 0; i < array_size; ++i, ++mode_table) {
+		reg_addr = mode_table->reg_addr;
+		val = mode_table->val;
+
+		/* Write pixel timing RAM memory offset (0x0000 to 0x0097) */
+		ret =
+		    topaz2m_write_reg(sensor, TOPAZ2M_TIMING_RAM_INIT_ADDR, i);
+		delay_ms = mode_table->delay_ms;
+
+		if (ret != 0) {
+			goto err;
+		}
+
+		if (delay_ms) {
+			msleep(delay_ms);
+		}
+
+		/* Write pixel timing RAM memory data */
+		ret = topaz2m_write_reg(sensor, reg_addr, val);
+		delay_ms = mode_table->delay_ms;
+
+		if (ret != 0) {
+			goto err;
+		}
+
+		if (delay_ms) {
+			msleep(delay_ms);
+		}
+	}
+
+err:
+	return ret;
+}
+
+static int
+topazm_set_ctrl_values(struct topaz2m *sensor,
+		enum topaz2m_mode_id id)
+{
+	struct i2c_client *client = NULL;
+	struct topaz2m_ctrls *ctrls = NULL;
+	s64 exposure_time_def = 0;
+	s64 frame_rate_max = 0;
+	s64 frame_rate_def = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+	ctrls = &sensor->ctrls;
+
+	switch (id) {
+		case TOPAZ2M_MODE_RAW8_1920X800:
+			frame_rate_max = TOPAZ2M_FRAME_RATE_RAW8_1920X800_MAX;
+			frame_rate_def = TOPAZ2M_FRAME_RATE_RAW8_1920X800_DEF;
+			exposure_time_def = TOPAZ2M_EXPOSURE_TIME_RAW8_1920X800_DEF;
+			break;
+
+		case TOPAZ2M_MODE_RAW8_1920X1080:
+		case TOPAZ2M_MODE_RAW8_ROI1:
+		case TOPAZ2M_MODE_RAW8_ROI2:
+			frame_rate_max = TOPAZ2M_FRAME_RATE_RAW8_1920X1080_MAX;
+			frame_rate_def = TOPAZ2M_FRAME_RATE_RAW8_1920X1080_DEF;
+			exposure_time_def = TOPAZ2M_EXPOSURE_TIME_RAW8_1920X1080_DEF;
+			break;
+
+		case TOPAZ2M_MODE_RAW10_1920X800:
+			frame_rate_max = TOPAZ2M_FRAME_RATE_RAW10_1920X800_MAX;
+			frame_rate_def = TOPAZ2M_FRAME_RATE_RAW10_1920X800_DEF;
+			exposure_time_def = TOPAZ2M_EXPOSURE_TIME_RAW10_1920X800_DEF;
+			break;
+
+		case TOPAZ2M_MODE_RAW10_1920X1080:
+		case TOPAZ2M_MODE_RAW10_ROI1:
+		case TOPAZ2M_MODE_RAW10_ROI2:
+			frame_rate_max = TOPAZ2M_FRAME_RATE_RAW10_1920X1080_MAX;
+			frame_rate_def = TOPAZ2M_FRAME_RATE_RAW10_1920X1080_DEF;
+			exposure_time_def = TOPAZ2M_EXPOSURE_TIME_RAW10_1920X1080_DEF;
+			break;
+
+		default:
+			frame_rate_max = TOPAZ2M_FRAME_RATE_RAW8_1920X800_MAX;
+			frame_rate_def = TOPAZ2M_FRAME_RATE_RAW8_1920X800_DEF;
+			exposure_time_def = TOPAZ2M_EXPOSURE_TIME_RAW8_1920X800_DEF;
+	}
+	
+	ret = v4l2_ctrl_modify_range(
+			ctrls->frame_rate, TOPAZ2M_FRAME_RATE_MIN,
+			frame_rate_max, TOPAZ2M_FRAME_RATE_STEP, frame_rate_def);
+
+	if (ret != 0) {
+		dev_err(&client->dev,
+			"Failed to updated frame rate control range, ret=%d\n", ret);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_modify_range(
+			ctrls->exposure, TOPAZ2M_EXPOSURE_TIME_MIN,
+			TOPAZ2M_EXPOSURE_TIME_MAX, TOPAZ2M_EXPOSURE_TIME_STEP, exposure_time_def);
+	
+	if (ret != 0) {
+		dev_err(&client->dev,
+			"Failed to updated exposure control range, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct topaz2m *sensor = to_topaz2m(client);
+	static topaz2m_reg *conf_table = NULL;
+	s32 array_size = 0;
+	int ret = 0;
+
+	if (sensor->streaming == !enable) {
+
+		conf_table = mode_table_common;
+		array_size = ARRAY_SIZE(mode_table_common);
+		ret = topaz2m_write_table(sensor, conf_table, array_size);
+		if (ret != 0) {
+			dev_err(&client->dev, "Failed to set common table\n");
+			return ret;
+		}
+
+		conf_table = pixel_timing;
+		array_size = ARRAY_SIZE(pixel_timing);
+		ret =
+		    topaz2m_write_pixel_timing_table(sensor, conf_table,
+						     array_size);
+		if (ret != 0) {
+			dev_err(&client->dev, "Failed to set pixel timing\n");
+			return ret;
+		}
+
+		switch (sensor->current_mode->id) {
+
+			case TOPAZ2M_MODE_RAW8_1920X800:
+				conf_table = mode_1920x800_130fps;
+				array_size = ARRAY_SIZE(mode_1920x800_130fps);
+				break;
+
+			case TOPAZ2M_MODE_RAW8_1920X1080:
+			case TOPAZ2M_MODE_RAW8_ROI1:
+			case TOPAZ2M_MODE_RAW8_ROI2:
+				conf_table = mode_1920x1080_100fps;
+				array_size = ARRAY_SIZE(mode_1920x1080_100fps);
+				break;
+
+			case TOPAZ2M_MODE_RAW10_1920X800:
+				conf_table = mode_1920x800_80fps;
+				array_size = ARRAY_SIZE(mode_1920x800_80fps);
+				break;
+
+			case TOPAZ2M_MODE_RAW10_1920X1080:
+			case TOPAZ2M_MODE_RAW10_ROI1:
+			case TOPAZ2M_MODE_RAW10_ROI2:
+				conf_table = mode_1920x1080_65fps;
+				array_size = ARRAY_SIZE(mode_1920x1080_65fps);
+				break;
+
+			default:
+				dev_err(&client->dev,
+					"Format does not match with a supported mode. Setting default mode.\n");
+				conf_table = mode_1920x1080_100fps;
+				array_size = ARRAY_SIZE(mode_1920x1080_100fps);
+		}
+
+		ret = topaz2m_write_table(sensor, conf_table, array_size);
+		if (ret != 0) {
+			dev_err(&client->dev, "Failed to set format table\n");
+			return ret;
+		}
+
+		/* Set controls values */
+		v4l2_ctrl_handler_setup(sensor->subdev.ctrl_handler);
+
+		/* Set device to acquisition mode */
+		ret =
+		    topaz2m_write_reg(sensor, TOPAZ2M_STANDBY_REG_ADDR,
+				      TOPAZ2M_ACQUISITION_MODE_VAL);
+		if (ret != 0) {
+			dev_err(&client->dev, "Failed to set stream\n");
+			return ret;
+		}
+	} else {
+		/* Set device to standby mode */
+		ret =
+		    topaz2m_write_reg(sensor, TOPAZ2M_STANDBY_REG_ADDR,
+				      TOPAZ2M_STANDBY_MODE_VAL);
+		if (ret != 0) {
+			dev_err(&client->dev, "Failed to set standby mode\n");
+			return ret;
+		}
+	}
+
+	if (!ret) {
+		sensor->streaming = enable;
+	}
+
+	return ret;
+}
+
+static int topaz2m_try_fmt_internal(struct v4l2_mbus_framefmt *fmt,
+				    const struct topaz2m_mode_info **new_mode,
+					struct i2c_client *client)
+{
+	struct topaz2m *sensor = to_topaz2m(client);
+	int efective_height = 0;
+	int efective_width = 0;
+	int i = 0;
+
+	for (i = 0; i < TOPAZ2M_NUM_MODES; i++) {
+		if (i == TOPAZ2M_MODE_RAW8_ROI1 || i == TOPAZ2M_MODE_RAW10_ROI1) {
+			efective_height = sensor->roi1_height / sensor->v_sub_sampling_num;
+			efective_width = sensor->roi_width / sensor->h_sub_sampling_num;
+		} else if (i == TOPAZ2M_MODE_RAW8_ROI2 || i == TOPAZ2M_MODE_RAW10_ROI2) {
+			/* ROI2 modes height will be the sum of both ROIs heights */
+			efective_height =
+				(sensor->roi1_height + sensor->roi2_height) / sensor->v_sub_sampling_num;
+			efective_width = sensor->roi_width / sensor->h_sub_sampling_num;
+		} else {
+			efective_height = topaz2m_modes[i].height / sensor->v_sub_sampling_num;
+			efective_width = topaz2m_modes[i].width / sensor->h_sub_sampling_num;
+		}
+
+		if (topaz2m_modes[i].fmt_code == fmt->code &&
+			efective_width == fmt->width &&
+			efective_height == fmt->height) {
+				if (i == TOPAZ2M_MODE_RAW8_ROI1 || i == TOPAZ2M_MODE_RAW10_ROI1) {
+					sensor->roi1_enable = true;
+				} else if (i == TOPAZ2M_MODE_RAW8_ROI2 || i == TOPAZ2M_MODE_RAW10_ROI2) {
+					sensor->roi2_enable = true;
+				}
+				else {
+					sensor->roi1_enable = false;
+					sensor->roi2_enable = false;
+				}
+			break;
+		}
+	}
+	if (i >= TOPAZ2M_NUM_MODES) {
+		i = TOPAZ2M_DEFAULT_MODE;
+		efective_height = topaz2m_modes[i].height / sensor->v_sub_sampling_num;
+		efective_width = topaz2m_modes[i].width / sensor->h_sub_sampling_num;
+		sensor->roi1_enable = false;
+		sensor->roi2_enable = false;
+		fmt->height = efective_height;
+		fmt->width = efective_width;
+		dev_warn(&client->dev,
+			"Format and resolution mismatch. Setting default values.\n");
+	}
+	if (new_mode) {
+		*new_mode = &topaz2m_modes[i];
+	}
+
+	fmt->code = topaz2m_modes[i].fmt_code;
+	fmt->colorspace = topaz2m_modes[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+
+	return 0;
+}
+
+static int topaz2m_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct topaz2m *sensor = to_topaz2m(client);
+	const struct topaz2m_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt = NULL;
+	int ret = 0;
+
+	if (format->pad != 0) {
+		return -EINVAL;
+	}
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		return ret;
+	}
+
+	ret = topaz2m_try_fmt_internal(mbus_fmt, &new_mode, client);
+	if (ret) {
+		return ret;
+	}
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	} else {
+		fmt = &sensor->fmt;
+	}
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		topazm_set_ctrl_values(sensor, sensor->current_mode->id);
+	}
+
+	sensor->fmt = *mbus_fmt;
+
+	return ret;
+}
+
+static int topaz2m_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+
+	struct v4l2_mbus_framefmt *fmt = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct topaz2m *sensor = to_topaz2m(client);
+
+	if (!format->pad) {
+		dev_err(&client->dev, "Failed to get format\n");
+		return -EINVAL;
+	}
+
+	fmt = &sensor->fmt;
+
+	return 0;
+}
+
+static int topaz2m_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index >= TOPAZ2M_NUM_FORMATS) {
+		return -EINVAL;
+	}
+
+	code->code = topaz2m_modes[code->index * TOPAZ2M_NUM_FRAMESIZES].fmt_code;
+
+	return 0;
+}
+
+static int topaz2m_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct topaz2m *sensor = to_topaz2m(client);
+	int mode_index = 0;
+	int i = 0;
+
+	if (fse->index < 0 || fse->index >= TOPAZ2M_NUM_FRAMESIZES) {
+		return -EINVAL;
+	}
+
+	fse->max_width = topaz2m_modes[TOPAZ2M_DEFAULT_MODE].width;
+	fse->max_height = topaz2m_modes[TOPAZ2M_DEFAULT_MODE].height;
+
+	/* It is assumed that all the pixel formats have the same amount
+	 * of frame sizes.
+	 * The variable i will index each pixel format, and mode_index
+	 * will iterate through each resolution of the current pixel format.
+	 */
+	for (i = 0; i <= TOPAZ2M_NUM_FRAMESIZES; i = i + TOPAZ2M_NUM_FRAMESIZES) {
+		if (fse->code == topaz2m_modes[i].fmt_code) {
+			mode_index = i + fse->index;
+			if ((mode_index) == TOPAZ2M_MODE_RAW8_ROI1 || 
+				(mode_index) == TOPAZ2M_MODE_RAW10_ROI1) {
+				fse->max_width =
+					sensor->roi_width / sensor->h_sub_sampling_num;
+				fse->max_height =
+					sensor->roi1_height / sensor->v_sub_sampling_num;
+			} else if ((mode_index) == TOPAZ2M_MODE_RAW8_ROI2 || 
+					(mode_index) == TOPAZ2M_MODE_RAW10_ROI2) {
+				fse->max_width =
+					sensor->roi_width / sensor->h_sub_sampling_num;
+				/* ROI2 modes height will be the sum of both ROIs heights */
+				fse->max_height =
+					(sensor->roi1_height + sensor->roi2_height) / sensor->v_sub_sampling_num;
+			} else {
+				fse->max_width =
+					topaz2m_modes[mode_index].width / sensor->h_sub_sampling_num;
+				fse->max_height =
+					topaz2m_modes[mode_index].height / sensor->v_sub_sampling_num;
+			}
+			break;
+		}
+	}
+
+	fse->min_width = fse->max_width;
+	fse->min_height = fse->max_height;
+
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops topaz2m_subdev_core_ops = {
+	.s_power = topaz2m_set_power,
+};
+
+static struct v4l2_subdev_video_ops topaz2m_subdev_video_ops = {
+	.s_stream = topaz2m_set_stream
+};
+
+static const struct v4l2_subdev_pad_ops topaz2m_subdev_pad_ops = {
+	.enum_frame_size = topaz2m_enum_framesizes,
+	.enum_mbus_code = topaz2m_enum_mbus_code,
+	.set_fmt = topaz2m_set_fmt,
+	.get_fmt = topaz2m_get_fmt,
+};
+
+static struct v4l2_subdev_ops topaz2m_subdev_ops = {
+	.core = &topaz2m_subdev_core_ops,
+	.video = &topaz2m_subdev_video_ops,
+	.pad = &topaz2m_subdev_pad_ops,
+};
+
+static int topaz2m_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct topaz2m *sensor;
+	struct device *dev = &client->dev;
+	struct v4l2_mbus_framefmt *fmt;
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor) {
+		dev_err(dev, "Unable to allocate memory!");
+		return -ENOMEM;
+	}
+
+	sensor->i2c_client = client;
+
+	fmt = &sensor->fmt;
+	fmt->code = topaz2m_modes[TOPAZ2M_DEFAULT_MODE].fmt_code;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = topaz2m_modes[TOPAZ2M_DEFAULT_MODE].width;
+	fmt->height = topaz2m_modes[TOPAZ2M_DEFAULT_MODE].height;
+	fmt->field = V4L2_FIELD_NONE;
+
+	sensor->current_mode = &topaz2m_modes[TOPAZ2M_DEFAULT_MODE];
+	sensor->roi1_height = TOPAZ2M_ROI1_HEIGHT_DEF;
+	sensor->roi2_height = TOPAZ2M_ROI2_HEIGHT_DEF;
+	sensor->roi_width = TOPAZ2M_ROI_WIDTH_DEF;
+	sensor->h_sub_sampling_num = TOPAZ2M_SUB_SAMPLING_DEF_NUM;
+	sensor->v_sub_sampling_num = TOPAZ2M_SUB_SAMPLING_DEF_NUM;
+
+	sensor->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(sensor->regmap)) {
+		dev_err(dev,
+			"Regmap init failed: %ld\n", PTR_ERR(sensor->regmap));
+		return -ENODEV;
+	}
+
+	sensor->pwdn_gpio = of_get_named_gpio(dev->of_node, "pwdn-gpio", 0);
+	if (!gpio_is_valid(sensor->pwdn_gpio)) {
+		dev_err(dev, "No sensor pwdn pin available");
+	} else {
+		ret = devm_gpio_request_one(dev, sensor->pwdn_gpio,
+					    GPIOF_OUT_INIT_LOW, "topaz2m_pwdn");
+		if (ret != 0) {
+			dev_err(dev, "Failed to set pwdn pin\n");
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u32(dev->of_node, "csi_id", &(sensor->csi));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+	ret = topaz2m_power_on(sensor);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Read sensor model */
+	ret = topaz2m_read_reg(sensor, TOPAZ2M_MODEL_ID_ADDR, &reg_val);
+	if (ret != 0) {
+		dev_err(dev, "Error during i2c read probe, ret=%d\n", ret);
+		return ret;
+	}
+
+	if (reg_val == TOPAZ2M_MODEL_ID_VAL) {
+		dev_info(dev, "TOPAZ2M sensor found\n");
+	} else {
+		dev_err(dev, "No TOPAZ2M sensor found\n");
+		ret = -ENODEV;
+		return ret;
+	}
+
+	v4l2_i2c_subdev_init(&sensor->subdev, client, &topaz2m_subdev_ops);
+
+	ret = topaz2m_init_controls(sensor);
+	if (ret != 0) {
+		dev_err(dev, "Failed initializing controls, ret=%d\n", ret);
+	}
+
+	ret = v4l2_async_register_subdev(&sensor->subdev);
+	if (ret != 0) {
+		dev_err(dev, "Async register failed, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct topaz2m *sensor = to_topaz2m(client);
+
+	v4l2_async_unregister_subdev(sd);
+
+	topaz2m_power_off(sensor);
+
+	return 0;
+}
+
+static int topaz2m_init_controls(struct topaz2m *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &topaz2m_ctrl_ops;
+	struct topaz2m_ctrls *ctrls = NULL;
+	struct v4l2_ctrl_handler *hdl = NULL;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	ctrls = &sensor->ctrls;
+	hdl = &ctrls->handler;
+
+	v4l2_ctrl_handler_init(hdl, TOPAZ2_NUM_CTRLS_HINT);
+
+	hdl->lock = &sensor->lock;
+
+	ctrls->ana_gain =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_ANALOGUE_GAIN,
+					ARRAY_SIZE(topaz2m_analog_gain_ops) - 1, TOPAZ2M_ANA_GAIN_MIN,
+					TOPAZ2M_ANA_GAIN_DEF, topaz2m_analog_gain_ops);
+
+	ctrls->dig_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_DIGITAL_GAIN,
+					TOPAZ2M_DIG_GAIN_MIN, TOPAZ2M_DIG_GAIN_MAX,
+					TOPAZ2M_DIG_GAIN_STEP, TOPAZ2M_DIG_GAIN_DEF);
+
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					TOPAZ2M_EXPOSURE_TIME_MIN, TOPAZ2M_EXPOSURE_TIME_MAX,
+					TOPAZ2M_EXPOSURE_TIME_STEP, TOPAZ2M_EXPOSURE_TIME_RAW8_1920X800_DEF);
+
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					TOPAZ2M_FLIP_MIN, TOPAZ2M_FLIP_MAX,
+					TOPAZ2M_FLIP_STEP, TOPAZ2M_FLIP_DEF);
+
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					TOPAZ2M_FLIP_MIN, TOPAZ2M_FLIP_MAX,
+					TOPAZ2M_FLIP_STEP, TOPAZ2M_FLIP_DEF);
+
+	ctrls->frame_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FRAME_RATE,
+					TOPAZ2M_FRAME_RATE_MIN, TOPAZ2M_FRAME_RATE_RAW8_1920X800_MAX,
+					TOPAZ2M_FRAME_RATE_STEP, TOPAZ2M_FRAME_RATE_RAW8_1920X800_DEF);
+
+	ctrls->test_pattern = 
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+				ARRAY_SIZE(topaz2m_test_pattern_ops) - 1, TOPAZ2M_TEST_PATTERN_MIN,
+				TOPAZ2M_TEST_PATTERN_DEF, topaz2m_test_pattern_ops);
+
+	ctrls->roi_width = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI_WIDTH,
+					TOPAZ2M_ROI_WIDTH_MIN, TOPAZ2M_ROI_WIDTH_MAX,
+					TOPAZ2M_ROI_WIDTH_STEP, TOPAZ2M_ROI_WIDTH_DEF);
+
+	ctrls->roi1_height = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI1_HEIGHT,
+					TOPAZ2M_ROI1_HEIGHT_MIN, TOPAZ2M_ROI1_HEIGHT_MAX,
+					TOPAZ2M_ROI1_HEIGHT_STEP, TOPAZ2M_ROI1_HEIGHT_DEF);
+
+	ctrls->roi2_height = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI2_HEIGHT,
+					TOPAZ2M_ROI2_HEIGHT_MIN, TOPAZ2M_ROI2_HEIGHT_MAX,
+					TOPAZ2M_ROI2_HEIGHT_STEP, TOPAZ2M_ROI2_HEIGHT_DEF);
+
+	ctrls->roi_offset_col = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI_OFFSET_COL,
+					TOPAZ2M_ROI_OFFSET_COL_MIN, TOPAZ2M_ROI_OFFSET_COL_MAX,
+					TOPAZ2M_ROI_OFFSET_STEP, TOPAZ2M_ROI_OFFSET_COL_DEF);
+
+	ctrls->roi1_offset_row = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI1_OFFSET_ROW,
+					TOPAZ2M_ROI1_OFFSET_ROW_MIN, TOPAZ2M_ROI1_OFFSET_ROW_MAX,
+					TOPAZ2M_ROI_OFFSET_STEP, TOPAZ2M_ROI1_OFFSET_ROW_DEF);
+
+	ctrls->roi2_offset_row = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ROI2_OFFSET_ROW,
+					TOPAZ2M_ROI2_OFFSET_ROW_MIN, TOPAZ2M_ROI2_OFFSET_ROW_MAX,
+					TOPAZ2M_ROI_OFFSET_STEP, TOPAZ2M_ROI2_OFFSET_ROW_DEF);
+
+	ctrls->h_sub_sampling = 
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_H_SUB_SAMPLING,
+				ARRAY_SIZE(topaz2m_sub_sampling_ops) - 1, TOPAZ2M_SUB_SAMPLING_MIN,
+				TOPAZ2M_SUB_SAMPLING_DEF, topaz2m_sub_sampling_ops);
+
+	ctrls->v_sub_sampling = 
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_V_SUB_SAMPLING,
+				ARRAY_SIZE(topaz2m_sub_sampling_ops) - 1, TOPAZ2M_SUB_SAMPLING_MIN,
+				TOPAZ2M_SUB_SAMPLING_DEF, topaz2m_sub_sampling_ops);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	sensor->subdev.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int topaz2m_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct topaz2m *sensor = sd_to_topaz2m(sd);
+	struct i2c_client *client = sensor->i2c_client;
+	s32 value = ctrl->val;
+	int ret = 0;
+
+	switch (ctrl->id) {
+		case V4L2_CID_ANALOGUE_GAIN:
+			topaz2m_set_analog_gain(sensor, value);
+			break;
+		case V4L2_CID_DIGITAL_GAIN:
+			topaz2m_set_digital_gain(sensor, value);
+			break;
+		case V4L2_CID_EXPOSURE:
+			topaz2m_set_exposure(sensor, value);
+			break;
+		case V4L2_CID_HFLIP:
+			topaz2m_set_flip(sensor, value, TOPAZ2M_HFLIP_SHIFT);
+			break;
+		case V4L2_CID_VFLIP:
+			topaz2m_set_flip(sensor, value, TOPAZ2M_VFLIP_SHIFT);
+			break;
+		case V4L2_CID_FRAME_RATE:
+			topaz2m_set_frame_rate(sensor, value);
+			break;
+		case V4L2_CID_TEST_PATTERN:
+			topaz2m_set_test_pattern(sensor, value);
+			break;
+		case V4L2_CID_ROI_WIDTH:
+			topaz2m_set_roi_size(sensor, value, TOPAZ2M_ROI_WIDTH_ADDR);
+			break;
+		case V4L2_CID_ROI1_HEIGHT:
+			topaz2m_set_roi_size(sensor, value, TOPAZ2M_ROI1_HEIGHT_ADDR);
+			break;
+		case V4L2_CID_ROI2_HEIGHT:
+			topaz2m_set_roi_size(sensor, value, TOPAZ2M_ROI2_HEIGHT_ADDR);
+			break;
+		case V4L2_CID_ROI_OFFSET_COL:
+			topaz2m_set_roi_offset(sensor, value, TOPAZ2M_ROI_OFFSET_COL_ADDR);
+			break;
+		case V4L2_CID_ROI1_OFFSET_ROW:
+			topaz2m_set_roi_offset(sensor, value, TOPAZ2M_ROI1_OFFSET_ROW_ADDR);
+			break;
+		case V4L2_CID_ROI2_OFFSET_ROW:
+			topaz2m_set_roi_offset(sensor, value, TOPAZ2M_ROI2_OFFSET_ROW_ADDR);
+			break;
+		case V4L2_CID_H_SUB_SAMPLING:
+			topaz2m_set_sub_sampling(sensor, value, TOPAZ2M_H_SUB_SAMPLING_SHIFT);
+			break;
+		case V4L2_CID_V_SUB_SAMPLING:
+			topaz2m_set_sub_sampling(sensor, value, TOPAZ2M_V_SUB_SAMPLING_SHIFT);
+			break;
+		default:
+			dev_warn(&client->dev, "Unhandled control %08x (%s)\n",
+				ctrl->id, v4l2_ctrl_get_name(ctrl->id));
+			ret = -ENOTTY;
+			break;
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_analog_gain(struct topaz2m *sensor, s32 value)
+{
+	struct i2c_client *client = NULL;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret = topaz2m_write_reg(sensor, TOPAZ2M_ANA_GAIN_ADDR, (u16)value);
+
+	if (ret) {
+		dev_err(&client->dev, "Failed to write new gain value, ret=%d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_digital_gain(struct topaz2m *sensor, s32 value)
+{
+	struct i2c_client *client = NULL;
+	u16 digital_gain = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	if (value >= TOPAZ2M_DIG_GAIN_MAX) {
+		value = TOPAZ2M_DIG_GAIN_MAX - 1;
+	}
+
+	digital_gain = value;
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_DIG_GAIN_ADDR, digital_gain);
+	if (ret) {
+		dev_err(&client->dev, "Failed to write new gain value, ret=%d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_exposure(struct topaz2m *sensor, s32 value)
+{
+	struct i2c_client *client = NULL;
+	unsigned int exposure_time_base = 0;
+	unsigned int exposure_coarse_time = 0;
+	unsigned int exposure_fine_time = 0;
+	unsigned int frame_rate_period = 0;
+	unsigned int line_length = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret =
+		topaz2m_read_reg(sensor, TOPAZ2M_LINE_LENGTH_ADDR, &line_length);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during line length register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	ret =
+		topaz2m_read_reg(sensor, TOPAZ2M_FRAME_RATE_PERIOD_ADDR, &frame_rate_period);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during frame rate period register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	exposure_time_base = value * TOPAZ2M_EXPOSURE_CONV_FACTOR;
+
+	exposure_coarse_time = exposure_time_base / line_length;
+
+	exposure_fine_time = exposure_time_base - (exposure_coarse_time * line_length);
+
+	if (exposure_fine_time >= line_length) {
+		exposure_fine_time = line_length - 1;
+	}
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_EXPOSURE_COARSE_TIME_ADDR, exposure_coarse_time);
+	if (ret) {
+		dev_err(&client->dev, "Failed to write new exposure coarse time value, ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_EXPOSURE_FINE_TIME_ADDR, exposure_fine_time);
+	if (ret) {
+		dev_err(&client->dev, "Failed to write new exposure fine time value, ret=%d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_flip(struct topaz2m *sensor, s32 do_flip, int shift)
+{
+	struct i2c_client *client = NULL;
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret = topaz2m_read_reg(sensor, TOPAZ2M_ROI1_ADDR, &reg_val);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during ROI1 (flip) register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	if (do_flip) {
+		reg_val |= 1U << shift;
+	} else {
+		reg_val &= ~(1U << shift);
+	}
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_ROI1_ADDR, reg_val);
+
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write new flip value, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_frame_rate(struct topaz2m *sensor, s32 value)
+{
+	struct i2c_client *client = NULL;
+	unsigned int frame_rate_period = 0;
+	unsigned int line_length = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret = topaz2m_read_reg(sensor, TOPAZ2M_LINE_LENGTH_ADDR, &line_length);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during line length register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	frame_rate_period = TOPAZ2M_MASTER_CLK_FREQ_HZ / (value * line_length);
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_FRAME_RATE_PERIOD_ADDR,
+				  frame_rate_period);
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write new frame rate period value, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_test_pattern(struct topaz2m *sensor, s32 value)
+{
+	struct i2c_client *client = NULL;
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret = topaz2m_read_reg(sensor, TOPAZ2M_TEST_PATTERN_ADDR, &reg_val);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during test pattern register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	reg_val = ((reg_val >> 2) << 2) + value;
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_TEST_PATTERN_ADDR, reg_val);
+
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write test pattern value, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_roi_offset(struct topaz2m *sensor, s32 value, u8 offset_addr)
+{
+	struct i2c_client *client = NULL; 
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret =
+		topaz2m_write_reg(sensor, offset_addr, value);
+
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write new ROI offset value, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_roi_size(struct topaz2m *sensor, s32 value, u8 size_addr)
+{
+	struct i2c_client *client = NULL;
+	unsigned int reg_val = 0;
+	int total_height = 0;
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	if (size_addr == TOPAZ2M_ROI_WIDTH_ADDR) {
+		sensor->roi_width = value;
+	} else {
+		if (size_addr == TOPAZ2M_ROI1_HEIGHT_ADDR) {
+			sensor->roi1_height = value;
+		} else {
+			sensor->roi2_height = value;
+		}
+
+		total_height = sensor->roi1_height + sensor->roi2_height;
+
+		if ((total_height) > TOPAZ2M_ROI1_HEIGHT_MAX) {
+			dev_warn(&client->dev,
+				"Warning, total height ROI1+ROI2=%d is bigger than %d limit\n",
+				total_height, TOPAZ2M_ROI1_HEIGHT_MAX);
+		}
+	}
+
+	if (!(sensor->roi1_enable || sensor->roi2_enable)) {
+		return ret;
+	}
+
+	if (sensor->roi2_enable) {
+
+		/* If roi2_enable flag is on, a bit has to be set on
+		 * the sensor to enable SIMR
+		 */
+
+		ret = topaz2m_read_reg(sensor, TOPAZ2M_SIMR_ENABLE_ADDR, &reg_val);
+		if (ret) {
+			dev_err(&client->dev,
+				"Error during reg_dig_config_1 register read, ret=%d\n", ret);
+			return ret;
+		}
+
+		reg_val |= 1U << TOPAZ2M_SIMR_ENABLE_SHIFT;
+		
+		ret = topaz2m_write_reg(sensor, TOPAZ2M_SIMR_ENABLE_ADDR, reg_val);
+	}
+
+	ret = topaz2m_write_reg(sensor, size_addr, value);
+
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write new ROI size value, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+static int topaz2m_set_sub_sampling(struct topaz2m *sensor, s32 value, int shift)
+{
+	struct i2c_client *client = NULL;
+	unsigned int reg_val = 0; 
+	int ret = 0;
+
+	if (!sensor) {
+		return -EINVAL;
+	}
+
+	client = sensor->i2c_client;
+
+	ret = topaz2m_read_reg(sensor, TOPAZ2M_ROI1_ADDR, &reg_val);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error during ROI1 (sub sampling) register read, ret=%d\n", ret);
+		return ret;
+	}
+
+	reg_val &= ~(TOPAZ2M_SUB_SAMPLING_MASK << shift);
+	reg_val |= value << shift;
+
+	ret =
+		topaz2m_write_reg(sensor, TOPAZ2M_ROI1_ADDR, reg_val);
+
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to write new sub sampling value, ret=%d\n", ret);
+	} else if (shift == TOPAZ2M_H_SUB_SAMPLING_SHIFT){
+		sensor->h_sub_sampling_num = 1 << value;
+	} else if (shift == TOPAZ2M_V_SUB_SAMPLING_SHIFT) {
+		sensor->v_sub_sampling_num = 1 << value ;
+	}
+
+	return ret;
+}
+
+static struct of_device_id topaz2m_of_match[] = {
+	{.compatible = "teledyne,topaz2m", },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, topaz2m_of_match);
+
+static const struct i2c_device_id topaz2m_id[] = {
+	{ "topaz2m", 0 },
+	{ }
+};
+
+static struct i2c_driver topaz2m_i2c_driver = {
+	.driver = {
+		   .name = "topaz2m",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(topaz2m_of_match),
+		    },
+	.probe = topaz2m_probe,
+	.remove = topaz2m_remove,
+	.id_table = topaz2m_id,
+};
+
+module_i2c_driver(topaz2m_i2c_driver);
+
+MODULE_AUTHOR("RidgeRun, LLC");
+MODULE_DESCRIPTION("TOPAZ2M Camera Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1.0");
+MODULE_ALIAS("CSI");
diff --git a/drivers/media/i2c/teledyne-topaz2m.h b/drivers/media/i2c/teledyne-topaz2m.h
new file mode 100644
index 000000000..22d765a0c
--- /dev/null
+++ b/drivers/media/i2c/teledyne-topaz2m.h
@@ -0,0 +1,621 @@
+/*
+ * teledyne-topaz2m_mode_tbls.h - topaz2m sensor driver
+ *
+ * Copyright (c) 2022, RidgeRun. All rights reserved.
+ *
+ * Contact us: support@ridgerun.com
+ *
+ * Authors: Alejandro Flores Herrera <alejandro.flores@ridgerun.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef TOPAZ2M_I2C_TABLES
+#define TOPAZ2M_I2C_TABLES
+
+struct reg_value {
+    u8 reg_addr;
+    u16 val;
+    u32 delay_ms;
+};
+
+typedef struct reg_value topaz2m_reg;
+
+static topaz2m_reg  mode_table_common[] = {
+
+    {0x01, 0x0000,0},
+    {0x02, 0x0001,0},
+    {0x03, 0x002f,0}
+};
+
+/* 1920x800@80fps, 2 lanes, raw10 */
+static topaz2m_reg  mode_1920x800_80fps[] = {
+
+    {0x04, 0xa0d0,0},
+    {0x05, 0x0015,0},
+    {0x06, 0x028a,0},
+    {0x07, 0x03c1,0},
+    {0x08, 0x0000,0},
+    {0x09, 0x0000,0},
+    {0x0a, 0x1a1f,0},
+    {0x0b, 0x0320,0},
+    {0x0c, 0x0000,0},
+    {0x0d, 0x0000,0},
+    {0x0e, 0x0100,0},
+    {0x0f, 0x0320,0},
+    {0x10, 0x0780,0},
+    {0x11, 0x0000,0},
+    {0x12, 0x0000,0},
+    {0x13, 0x0000,0},
+    {0x14, 0x0005,0},
+    {0x15, 0x0000,0},
+    {0x16, 0x0000,0},
+    {0x17, 0x0100,0},
+    {0x18, 0x0438,0},
+    {0x19, 0x0000,0},
+    {0x1a, 0x0000,0},
+    {0x1b, 0x0000,0},
+    {0x1c, 0x0000,0},
+    {0x1d, 0x0000,0},
+    {0x1e, 0x0100,0},
+    {0x1f, 0x0100,0},
+    {0x20, 0x0100,0},
+    {0x21, 0x0100,0},
+    {0x22, 0x0000,0},
+    {0x23, 0x0000,0},
+    {0x24, 0x0000,0},
+    {0x25, 0x0009,0},
+    {0x26, 0x0000,0},
+    {0x27, 0x1068,0},
+    {0x28, 0x015e,0},
+    {0x29, 0x0782,0},
+    {0x2a, 0x0008,0},
+    {0x2b, 0x040d,0},
+    {0x2c, 0x020d,0},
+    {0x2d, 0x104c,0},
+    {0x2e, 0x001f,0},
+    {0x2f, 0x0020,0},
+    {0x30, 0x0000,0},
+    {0x80, 0x3f87,0},
+    {0x81, 0x17ff,0},
+    {0x82, 0x2924,0},
+    {0x83, 0x0892,0},
+    {0x84, 0x09cd,0},
+    {0x85, 0x11ab,0},
+    {0x86, 0x004b,0},
+    {0x87, 0x0000,0},
+    {0x88, 0x8000,0},
+    {0x89, 0x00aa,0},
+    {0x8a, 0x000a,0},
+    {0x8b, 0x0002,0},
+    {0x8c, 0x2002,0},
+    {0x8d, 0x0000,0},
+    {0x8e, 0x003f,0},
+    {0x8f, 0x79eb,0},
+    {0x90, 0x4eaf,0},
+    {0x91, 0x0001,0},
+    {0x92, 0x0138,0},
+    {0x93, 0x0384,0},
+    {0x94, 0x0000,0},
+    {0x95, 0x1728,0},
+    {0x96, 0x001a,0},
+    {0x97, 0x0008,0},
+    {0x98, 0x0000,0},
+    {0x99, 0x040a,0},
+    {0x9a, 0x0010,0},
+    {0x9b, 0x0090,0},
+    {0x9c, 0x0a3e,0},
+    {0x9d, 0x0a2c,0},
+    {0x9e, 0x2528,0},
+    {0x9f, 0x0806,0},
+    {0xa0, 0x0c0a,0},
+    {0xa1, 0x0011,0},
+    {0xa2, 0x001e,0},
+    {0xa3, 0x0186,0},
+    {0xa4, 0x03fc,0},
+    {0xa5, 0x000c,0},
+    {0xa6, 0x0002,0},
+    {0xa7, 0x0000,0},
+    {0xa8, 0x0000,0},
+    {0xa9, 0x0000,0},
+    {0xaa, 0x0000,0},
+    {0xab, 0x0000,0},
+    {0xac, 0x0000,0},
+    {0xad, 0x0000,0},
+    {0xae, 0x0000,0},
+    {0xaf, 0x0000,0},
+    {0xb0, 0x0000,0},
+    {0xb1, 0x0000,0},
+    {0xb2, 0x0439,0},
+    {0xb3, 0x0000,0},
+    {0xb4, 0x000c,0},
+    {0xb5, 0x0000,0},
+    {0xb6, 0x8ce0,0},
+    {0xb7, 0x002b,0}
+};
+
+/* 1920x1080@65fps, 2 lanes, raw10 */
+static topaz2m_reg  mode_1920x1080_65fps[] = {
+
+    {0x04, 0xa0d0,0},
+    {0x05, 0x0015,0},
+    {0x06, 0x028a,0},
+    {0x07, 0x049f,0},
+    {0x08, 0x0000,0},
+    {0x09, 0x0000,0},
+    {0x0a, 0x1a1f,0},
+    {0x0b, 0x0438,0},
+    {0x0c, 0x0000,0},
+    {0x0d, 0x0000,0},
+    {0x0e, 0x0100,0},
+    {0x0f, 0x0438,0},
+    {0x10, 0x0780,0},
+    {0x11, 0x0000,0},
+    {0x12, 0x0000,0},
+    {0x13, 0x0000,0},
+    {0x14, 0x0005,0},
+    {0x15, 0x0000,0},
+    {0x16, 0x0000,0},
+    {0x17, 0x0100,0},
+    {0x18, 0x0438,0},
+    {0x19, 0x0000,0},
+    {0x1a, 0x0000,0},
+    {0x1b, 0x0000,0},
+    {0x1c, 0x0000,0},
+    {0x1d, 0x0000,0},
+    {0x1e, 0x0100,0},
+    {0x1f, 0x0100,0},
+    {0x20, 0x0100,0},
+    {0x21, 0x0100,0},
+    {0x22, 0x0000,0},
+    {0x23, 0x0000,0},
+    {0x24, 0x0000,0},
+    {0x25, 0x0009,0},
+    {0x26, 0x0000,0},
+    {0x27, 0x1068,0},
+    {0x28, 0x015e,0},
+    {0x29, 0x0782,0},
+    {0x2a, 0x0008,0},
+    {0x2b, 0x040d,0},
+    {0x2c, 0x020d,0},
+    {0x2d, 0x104c,0},
+    {0x2e, 0x001f,0},
+    {0x2f, 0x0020,0},
+    {0x30, 0x0000,0},
+    {0x80, 0x3f87,0},
+    {0x81, 0x17ff,0},
+    {0x82, 0x2924,0},
+    {0x83, 0x0892,0},
+    {0x84, 0x09cd,0},
+    {0x85, 0x11ab,0},
+    {0x86, 0x004b,0},
+    {0x87, 0x0000,0},
+    {0x88, 0x8000,0},
+    {0x89, 0x00aa,0},
+    {0x8a, 0x000a,0},
+    {0x8b, 0x0002,0},
+    {0x8c, 0x2002,0},
+    {0x8d, 0x0000,0},
+    {0x8e, 0x003f,0},
+    {0x8f, 0x79eb,0},
+    {0x90, 0x4eaf,0},
+    {0x91, 0x0001,0},
+    {0x92, 0x0138,0},
+    {0x93, 0x0384,0},
+    {0x94, 0x0000,0},
+    {0x95, 0x1728,0},
+    {0x96, 0x001a,0},
+    {0x97, 0x0008,0},
+    {0x98, 0x0000,0},
+    {0x99, 0x040a,0},
+    {0x9a, 0x0010,0},
+    {0x9b, 0x0090,0},
+    {0x9c, 0x0a3e,0},
+    {0x9d, 0x0a2c,0},
+    {0x9e, 0x2528,0},
+    {0x9f, 0x0806,0},
+    {0xa0, 0x0c0a,0},
+    {0xa1, 0x0011,0},
+    {0xa2, 0x001e,0},
+    {0xa3, 0x0186,0},
+    {0xa4, 0x03fc,0},
+    {0xa5, 0x000c,0},
+    {0xa6, 0x0002,0},
+    {0xa7, 0x0000,0},
+    {0xa8, 0x0000,0},
+    {0xa9, 0x0000,0},
+    {0xaa, 0x0000,0},
+    {0xab, 0x0000,0},
+    {0xac, 0x0000,0},
+    {0xad, 0x0000,0},
+    {0xae, 0x0000,0},
+    {0xaf, 0x0000,0},
+    {0xb0, 0x0000,0},
+    {0xb1, 0x0000,0},
+    {0xb2, 0x0439,0},
+    {0xb3, 0x0000,0},
+    {0xb4, 0x000c,0},
+    {0xb5, 0x0000,0},
+    {0xb6, 0x8ce0,0},
+    {0xb7, 0x002b,0}
+};
+
+/* 1920x800@130fps, 2 lanes, raw8 */
+static topaz2m_reg  mode_1920x800_130fps[] = {
+    {0x04, 0xa0d0,0},
+    {0x05, 0x001a,0},
+    {0x06, 0x01a9,0},
+    {0x07, 0x0389,0},
+    {0x08, 0x0000,0},
+    {0x09, 0x0000,0},
+    {0x0a, 0x1a1f,0},
+    {0x0b, 0x0320,0},
+    {0x0c, 0x0000,0},
+    {0x0d, 0x0000,0},
+    {0x0e, 0x0100,0},
+    {0x0f, 0x0320,0},
+    {0x10, 0x0780,0},
+    {0x11, 0x0000,0},
+    {0x12, 0x0000,0},
+    {0x13, 0x0000,0},
+    {0x14, 0x0005,0},
+    {0x15, 0x0000,0},
+    {0x16, 0x0000,0},
+    {0x17, 0x0100,0},
+    {0x18, 0x0438,0},
+    {0x19, 0x0000,0},
+    {0x1a, 0x0000,0},
+    {0x1b, 0x0000,0},
+    {0x1c, 0x0000,0},
+    {0x1d, 0x0000,0},
+    {0x1e, 0x0100,0},
+    {0x1f, 0x0100,0},
+    {0x20, 0x0100,0},
+    {0x21, 0x0100,0},
+    {0x22, 0x0000,0},
+    {0x23, 0x0000,0},
+    {0x24, 0x0000,0},
+    {0x25, 0x0009,0},
+    {0x26, 0x0000,0},
+    {0x27, 0x1068,0},
+    {0x28, 0x015e,0},
+    {0x29, 0x0782,0},
+    {0x2a, 0x0008,0},
+    {0x2b, 0x040d,0},
+    {0x2c, 0x020d,0},
+    {0x2d, 0x104c,0},
+    {0x2e, 0x001f,0},
+    {0x2f, 0x0020,0},
+    {0x30, 0x0000,0},
+    {0x80, 0x3f87,0},
+    {0x81, 0x17ff,0},
+    {0x82, 0x2924,0},
+    {0x83, 0x0892,0},
+    {0x84, 0x09cd,0},
+    {0x85, 0x11ab,0},
+    {0x86, 0x004b,0},
+    {0x87, 0x0000,0},
+    {0x88, 0x8000,0},
+    {0x89, 0x00aa,0},
+    {0x8a, 0x000a,0},
+    {0x8b, 0x0002,0},
+    {0x8c, 0x2002,0},
+    {0x8d, 0x0000,0},
+    {0x8e, 0x003f,0},
+    {0x8f, 0x79eb,0},
+    {0x90, 0x4eaf,0},
+    {0x91, 0x0001,0},
+    {0x92, 0x0138,0},
+    {0x93, 0x0384,0},
+    {0x94, 0x0000,0},
+    {0x95, 0x1728,0},
+    {0x96, 0x001a,0},
+    {0x97, 0x0008,0},
+    {0x98, 0x0000,0},
+    {0x99, 0x040a,0},
+    {0x9a, 0x0010,0},
+    {0x9b, 0x0090,0},
+    {0x9c, 0x0a3e,0},
+    {0x9d, 0x0a2c,0},
+    {0x9e, 0x2528,0},
+    {0x9f, 0x0806,0},
+    {0xa0, 0x0c0a,0},
+    {0xa1, 0x0011,0},
+    {0xa2, 0x001e,0},
+    {0xa3, 0x0186,0},
+    {0xa4, 0x03fc,0},
+    {0xa5, 0x000c,0},
+    {0xa6, 0x0002,0},
+    {0xa7, 0x0000,0},
+    {0xa8, 0x0000,0},
+    {0xa9, 0x0000,0},
+    {0xaa, 0x0000,0},
+    {0xab, 0x0000,0},
+    {0xac, 0x0000,0},
+    {0xad, 0x0000,0},
+    {0xae, 0x0000,0},
+    {0xaf, 0x0000,0},
+    {0xb0, 0x0000,0},
+    {0xb1, 0x0000,0},
+    {0xb2, 0x0439,0},
+    {0xb3, 0x0000,0},
+    {0xb4, 0x000c,0},
+    {0xb5, 0x0000,0},
+    {0xb6, 0x8ce0,0},
+    {0xb7, 0x002b,0}
+};
+
+/* 1920x1080@100fps, 2 lanes, raw8 */
+static topaz2m_reg  mode_1920x1080_100fps[] = {
+
+    {0x04, 0xa0d0,0},
+    {0x05, 0x001a,0},
+    {0x06, 0x01a9,0},
+    {0x07, 0x0498,0},
+    {0x08, 0x0000,0},
+    {0x09, 0x0000,0},
+    {0x0a, 0x1a1f,0},
+    {0x0b, 0x0438,0},
+    {0x0c, 0x0000,0},
+    {0x0d, 0x0000,0},
+    {0x0e, 0x0100,0},
+    {0x0f, 0x0438,0},
+    {0x10, 0x0780,0},
+    {0x11, 0x0000,0},
+    {0x12, 0x0000,0},
+    {0x13, 0x0000,0},
+    {0x14, 0x0005,0},
+    {0x15, 0x0000,0},
+    {0x16, 0x0000,0},
+    {0x17, 0x0100,0},
+    {0x18, 0x0438,0},
+    {0x19, 0x0000,0},
+    {0x1a, 0x0000,0},
+    {0x1b, 0x0000,0},
+    {0x1c, 0x0000,0},
+    {0x1d, 0x0000,0},
+    {0x1e, 0x0100,0},
+    {0x1f, 0x0100,0},
+    {0x20, 0x0100,0},
+    {0x21, 0x0100,0},
+    {0x22, 0x0000,0},
+    {0x23, 0x0000,0},
+    {0x24, 0x0000,0},
+    {0x25, 0x0009,0},
+    {0x26, 0x0000,0},
+    {0x27, 0x1068,0},
+    {0x28, 0x015e,0},
+    {0x29, 0x0782,0},
+    {0x2a, 0x0008,0},
+    {0x2b, 0x040d,0},
+    {0x2c, 0x020d,0},
+    {0x2d, 0x104c,0},
+    {0x2e, 0x001f,0},
+    {0x2f, 0x0020,0},
+    {0x30, 0x0000,0},
+    {0x80, 0x3f87,0},
+    {0x81, 0x17ff,0},
+    {0x82, 0x2924,0},
+    {0x83, 0x0892,0},
+    {0x84, 0x09cd,0},
+    {0x85, 0x11ab,0},
+    {0x86, 0x004b,0},
+    {0x87, 0x0000,0},
+    {0x88, 0x8000,0},
+    {0x89, 0x00aa,0},
+    {0x8a, 0x000a,0},
+    {0x8b, 0x0002,0},
+    {0x8c, 0x2002,0},
+    {0x8d, 0x0000,0},
+    {0x8e, 0x003f,0},
+    {0x8f, 0x79eb,0},
+    {0x90, 0x4eaf,0},
+    {0x91, 0x0001,0},
+    {0x92, 0x0138,0},
+    {0x93, 0x0384,0},
+    {0x94, 0x0000,0},
+    {0x95, 0x1728,0},
+    {0x96, 0x001a,0},
+    {0x97, 0x0008,0},
+    {0x98, 0x0000,0},
+    {0x99, 0x040a,0},
+    {0x9a, 0x0010,0},
+    {0x9b, 0x0090,0},
+    {0x9c, 0x0a3e,0},
+    {0x9d, 0x0a2c,0},
+    {0x9e, 0x2528,0},
+    {0x9f, 0x0806,0},
+    {0xa0, 0x0c0a,0},
+    {0xa1, 0x0011,0},
+    {0xa2, 0x001e,0},
+    {0xa3, 0x0186,0},
+    {0xa4, 0x03fc,0},
+    {0xa5, 0x000c,0},
+    {0xa6, 0x0002,0},
+    {0xa7, 0x0000,0},
+    {0xa8, 0x0000,0},
+    {0xa9, 0x0000,0},
+    {0xaa, 0x0000,0},
+    {0xab, 0x0000,0},
+    {0xac, 0x0000,0},
+    {0xad, 0x0000,0},
+    {0xae, 0x0000,0},
+    {0xaf, 0x0000,0},
+    {0xb0, 0x0000,0},
+    {0xb1, 0x0000,0},
+    {0xb2, 0x0439,0},
+    {0xb3, 0x0000,0},
+    {0xb4, 0x000c,0},
+    {0xb5, 0x0000,0},
+    {0xb6, 0x8ce0,0},
+    {0xb7, 0x002b,0}
+};
+
+/* Pixel timing configuration */
+static topaz2m_reg pixel_timing[] = {
+    {0x50, 0x0552,0},
+    {0x50, 0xd550,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0xf551,0},
+    {0x50, 0x8551,0},
+    {0x50, 0xf550,0},
+    {0x50, 0x4550,0},
+    {0x50, 0xf552,0},
+    {0x50, 0xe552,0},
+    {0x50, 0x153a,0},
+    {0x50, 0xf532,0},
+    {0x50, 0x5532,0},
+    {0x50, 0xa552,0},
+    {0x50, 0xf152,0},
+    {0x50, 0xf152,0},
+    {0x50, 0x7152,0},
+    {0x50, 0x9156,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0xf114,0},
+    {0x50, 0x2114,0},
+    {0x50, 0xf110,0},
+    {0x50, 0xf110,0},
+    {0x50, 0xf110,0},
+    {0x50, 0xb110,0},
+    {0x50, 0xf510,0},
+    {0x50, 0x8510,0},
+    {0x50, 0x9550,0},
+    {0x50, 0x4552,0},
+    {0x50, 0x9512,0},
+    {0x50, 0xf532,0},
+    {0x50, 0xd532,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0xf53a,0},
+    {0x50, 0x553a,0},
+    {0x50, 0x142a,0},
+    {0x50, 0x202a,0},
+    {0x50, 0xf02e,0},
+    {0x50, 0xa02e,0},
+    {0x50, 0x802c,0},
+    {0x50, 0x300c,0},
+    {0x50, 0x404c,0},
+    {0x50, 0xf34c,0},
+    {0x50, 0xf34c,0},
+    {0x50, 0x734c,0},
+    {0x50, 0x014c,0},
+    {0x50, 0x304c,0},
+    {0x50, 0x9044,0},
+    {0x50, 0xf045,0},
+    {0x50, 0xf045,0},
+    {0x50, 0x5045,0},
+    {0x50, 0x6044,0},
+    {0x50, 0xe04c,0},
+    {0x50, 0xf14c,0},
+    {0x50, 0xf14c,0},
+    {0x50, 0x714c,0},
+    {0x50, 0x100c,0},
+    {0x50, 0x380c,0},
+    {0x50, 0x582c,0},
+    {0x50, 0x202c,0},
+    {0x50, 0x002c,0},
+    {0x50, 0x8028,0},
+    {0x50, 0xb02a,0},
+    {0x50, 0x742a,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0012,0},
+    {0x50, 0x000d,0},
+    {0x50, 0x0018,0},
+    {0x50, 0x0019,0},
+    {0x50, 0x0004,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x002a,0},
+    {0x50, 0x0012,0},
+    {0x50, 0x0037,0},
+    {0x50, 0x0050,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0},
+    {0x50, 0x0000,0}
+};
+
+#endif
diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index a45d01ed8..f8aef4be1 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -172,6 +172,8 @@
 #define NUM_FORMATS ARRAY_SIZE(formats)
 #define MX6SX_MAX_SENSORS    1
 
+#define NUM_CTRLS_HINT 5
+
 struct csi_signal_cfg_t {
 	unsigned data_width:3;
 	unsigned clk_mode:2;
@@ -266,6 +268,18 @@ static struct mx6s_fmt formats[] = {
 		.pixelformat	= V4L2_PIX_FMT_SBGGR8,
 		.mbus_code	= MEDIA_BUS_FMT_SBGGR8_1X8,
 		.bpp		= 1,
+	}, {
+		.name		= "Grey8 (Y8)",
+		.fourcc		= V4L2_PIX_FMT_GREY,
+		.pixelformat	= V4L2_PIX_FMT_GREY,
+		.mbus_code	= MEDIA_BUS_FMT_Y8_1X8,
+		.bpp		= 1,
+	}, {
+		.name		= "Grey10 (Y10)",
+		.fourcc		= V4L2_PIX_FMT_Y10,
+		.pixelformat	= V4L2_PIX_FMT_Y10,
+		.mbus_code	= MEDIA_BUS_FMT_Y10_1X10,
+		.bpp		= 2,
 	}
 };
 
@@ -315,8 +329,6 @@ struct mx6s_csi_dev {
 	void __iomem *regbase;
 	int irq;
 
-	u32      nextfb;
-	u32      skipframe;
 	u32	 type;
 	u32 bytesperline;
 	v4l2_std_id std;
@@ -446,8 +458,6 @@ static void csisw_reset(struct mx6s_csi_dev *csi_dev)
 	isr = csi_read(csi_dev, CSI_CSISR);
 	csi_write(csi_dev, isr, CSI_CSISR);
 
-	cr18 |= csi_dev->soc->baseaddr_switch;
-
 	/* Enable csi  */
 	cr18 |= BIT_CSI_ENABLE;
 	csi_write(csi_dev, cr18, CSI_CSICR18);
@@ -745,7 +755,6 @@ static int mx6s_csi_enable(struct mx6s_csi_dev *csi_dev)
 	unsigned long val;
 	int timeout, timeout2;
 
-	csi_dev->skipframe = 0;
 	csisw_reset(csi_dev);
 
 	if (pix->field == V4L2_FIELD_INTERLACED)
@@ -836,10 +845,12 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 	}
 
 	switch (csi_dev->fmt->pixelformat) {
+	case V4L2_PIX_FMT_GREY:
 	case V4L2_PIX_FMT_YUV32:
 	case V4L2_PIX_FMT_SBGGR8:
 		width = pix->width;
 		break;
+	case V4L2_PIX_FMT_Y10:
 	case V4L2_PIX_FMT_UYVY:
 	case V4L2_PIX_FMT_YUYV:
 		if (csi_dev->csi_mipi_mode == true)
@@ -857,7 +868,6 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 	if (csi_dev->csi_mipi_mode == true) {
 		cr1 = csi_read(csi_dev, CSI_CSICR1);
 		cr1 &= ~BIT_GCLK_MODE;
-		csi_write(csi_dev, cr1, CSI_CSICR1);
 
 		cr18 = csi_read(csi_dev, CSI_CSICR18);
 		cr18 &= ~BIT_MIPI_DATA_FORMAT_MASK;
@@ -869,18 +879,78 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
 			break;
 		case V4L2_PIX_FMT_SBGGR8:
+		case V4L2_PIX_FMT_GREY:
 			cr18 |= BIT_MIPI_DATA_FORMAT_RAW8;
 			break;
+		case V4L2_PIX_FMT_Y10:
+			cr18 |= BIT_MIPI_DATA_FORMAT_RAW10;
+			cr1 |= BIT_PIXEL_BIT;
+			break;
 		default:
 			pr_debug("   fmt not supported\n");
 			return -EINVAL;
 		}
 
+		csi_write(csi_dev, cr1, CSI_CSICR1);
 		csi_write(csi_dev, cr18, CSI_CSICR18);
 	}
 	return 0;
 }
 
+static int mx6s_debug_csi_registers(struct mx6s_csi_dev *csi_dev){
+
+	dev_info(csi_dev->dev, "%s CSI_CSICR1: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSICR1));
+	dev_info(csi_dev->dev, "%s CSI_CSICR2: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSICR2));
+	dev_info(csi_dev->dev, "%s CSI_CSICR3: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSICR3));
+	dev_info(csi_dev->dev, "%s CSI_STATFIFO: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_STATFIFO));
+	dev_info(csi_dev->dev, "%s CSI_CSIRXFIFO: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIRXFIFO));
+	dev_info(csi_dev->dev, "%s CSI_CSIRXCNT: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIRXCNT));
+	dev_info(csi_dev->dev, "%s CSI_CSISR: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSISR));
+
+	dev_info(csi_dev->dev, "%s CSI_CSIDBG: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIDBG));
+	dev_info(csi_dev->dev, "%s CSI_CSIDMASA_STATFIFO: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIDMASA_STATFIFO));
+	dev_info(csi_dev->dev, "%s CSI_CSIDMATS_STATFIFO: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIDMATS_STATFIFO));
+	dev_info(csi_dev->dev, "%s CSI_CSIDMASA_FB1: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIDMASA_FB1));
+	dev_info(csi_dev->dev, "%s CSI_CSIDMASA_FB2: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIDMASA_FB2));
+	dev_info(csi_dev->dev, "%s CSI_CSIFBUF_PARA: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIFBUF_PARA));
+	dev_info(csi_dev->dev, "%s CSI_CSIIMAG_PARA: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSIIMAG_PARA));
+	dev_info(csi_dev->dev, "%s CSI_CSICR18: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSICR18));
+	dev_info(csi_dev->dev, "%s CSI_CSICR19: 0x%x\n",
+		__func__, csi_read(csi_dev, CSI_CSICR19));
+
+	return 0;
+}
+
+static int mx6s_debug_pix_format(
+	struct mx6s_csi_dev *csi_dev, struct v4l2_format *f){
+
+	dev_info(csi_dev->dev, "%s pix.width %d",
+		__func__, f->fmt.pix.width);
+	dev_info(csi_dev->dev, "%s pix.height %d",
+		__func__, f->fmt.pix.height);
+	dev_info(csi_dev->dev, "%s pix.sizeimage %d",
+		__func__, f->fmt.pix.sizeimage);
+	dev_info(csi_dev->dev, "%s pix.field %d",
+		__func__, f->fmt.pix.field);
+
+	return 0;
+}
+
 static int mx6s_start_streaming(struct vb2_queue *vq, unsigned int count)
 {
 	struct mx6s_csi_dev *csi_dev = vb2_get_drv_priv(vq);
@@ -889,6 +959,8 @@ static int mx6s_start_streaming(struct vb2_queue *vq, unsigned int count)
 	unsigned long phys;
 	unsigned long flags;
 
+	mx6s_configure_csi(csi_dev);
+
 	if (count < 2)
 		return -ENOBUFS;
 
@@ -940,8 +1012,6 @@ static int mx6s_start_streaming(struct vb2_queue *vq, unsigned int count)
 	mx6s_update_csi_buf(csi_dev, phys, buf->internal.bufnum);
 	list_move_tail(csi_dev->capture.next, &csi_dev->active_bufs);
 
-	csi_dev->nextfb = 0;
-
 	spin_unlock_irqrestore(&csi_dev->slock, flags);
 
 	return mx6s_csi_enable(csi_dev);
@@ -1047,7 +1117,6 @@ static void mx6s_csi_frame_done(struct mx6s_csi_dev *csi_dev,
 	}
 
 	csi_dev->frame_count++;
-	csi_dev->nextfb = (bufnum == 0 ? 1 : 0);
 
 	/* Config discard buffer to active_bufs */
 	if (list_empty(&csi_dev->capture)) {
@@ -1130,7 +1199,6 @@ static irqreturn_t mx6s_csi_irq_handler(int irq, void *data)
 		cr18 |= BIT_CSI_ENABLE;
 		csi_write(csi_dev, cr18, CSI_CSICR18);
 
-		csi_dev->skipframe = 1;
 		pr_debug("base address switching Change Err.\n");
 	}
 
@@ -1145,22 +1213,9 @@ static irqreturn_t mx6s_csi_irq_handler(int irq, void *data)
 		 * PDM TKT230775 */
 		pr_debug("Skip two frames\n");
 	} else if (status & BIT_DMA_TSF_DONE_FB1) {
-		if (csi_dev->nextfb == 0) {
-			if (csi_dev->skipframe > 0)
-				csi_dev->skipframe--;
-			else
-				mx6s_csi_frame_done(csi_dev, 0, false);
-		} else
-			pr_warn("skip frame 0\n");
-
+		mx6s_csi_frame_done(csi_dev, 0, false);
 	} else if (status & BIT_DMA_TSF_DONE_FB2) {
-		if (csi_dev->nextfb == 1) {
-			if (csi_dev->skipframe > 0)
-				csi_dev->skipframe--;
-			else
-				mx6s_csi_frame_done(csi_dev, 1, false);
-		} else
-			pr_warn("skip frame 1\n");
+		mx6s_csi_frame_done(csi_dev, 1, false);
 	}
 
 	spin_unlock(&csi_dev->slock);
@@ -1896,6 +1951,9 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	snprintf(csi_dev->v4l2_dev.name,
 		 sizeof(csi_dev->v4l2_dev.name), "CSI");
 
+	v4l2_ctrl_handler_init(&csi_dev->ctrl_handler, NUM_CTRLS_HINT);
+	csi_dev->v4l2_dev.ctrl_handler = &csi_dev->ctrl_handler;
+
 	ret = v4l2_device_register(dev, &csi_dev->v4l2_dev);
 	if (ret < 0) {
 		dev_err(dev, "v4l2_device_register() failed: %d\n", ret);
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index e489c83ad..8c0bed58d 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -38,6 +38,7 @@
 #include <linux/videodev2.h>
 #include <media/v4l2-subdev.h>
 #include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
 
 static int debug;
 module_param(debug, int, 0644);
@@ -186,6 +187,8 @@ MODULE_PARM_DESC(debug, "Debug level (0-2)");
 
 #define DEFAULT_SCLK_CSIS_FREQ	166000000UL
 
+#define NUM_CTRLS_HINT 5
+
 enum {
 	ST_POWERED	= 1,
 	ST_STREAMING	= 2,
@@ -260,6 +263,7 @@ struct csi_state {
 	struct v4l2_subdev mipi_sd;
 	struct v4l2_subdev *sensor_sd;
 	struct v4l2_device	v4l2_dev;
+	struct v4l2_ctrl_handler  ctrl_handler;
 
 	u8 index;
 	struct platform_device *pdev;
@@ -322,6 +326,14 @@ static const struct csis_pix_format mipi_csis_formats[] = {
 		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
 		.data_alignment = 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_Y8_1X8,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
+		.data_alignment = 8,
+	}, {
+		.code	= MEDIA_BUS_FMT_Y10_1X10,
+		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW10,
+		.data_alignment = 10,
 	}
 };
 
@@ -345,9 +357,10 @@ static const struct csis_pix_format *find_csis_format(u32 code)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(mipi_csis_formats); i++)
+	for (i = 0; i < ARRAY_SIZE(mipi_csis_formats); i++) {
 		if (code == mipi_csis_formats[i].code)
 			return &mipi_csis_formats[i];
+	}
 	return NULL;
 }
 
@@ -942,6 +955,27 @@ static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
 	return 0;
 }
 
+static int subdev_notifier_complete(struct v4l2_async_notifier *async) {
+	struct csi_state *state = notifier_to_mipi_dev(async);
+	struct v4l2_device *dev = state->mipi_sd.v4l2_dev;
+
+	v4l2_info(&state->v4l2_dev,
+		"Adding v4l2 controls from (%s) to (%s)\n",
+		state->sensor_sd->name, state->v4l2_dev.name);
+
+	v4l2_ctrl_add_handler(state->v4l2_dev.ctrl_handler,
+		state->sensor_sd->ctrl_handler, NULL, TRUE);
+
+	v4l2_info(&state->v4l2_dev,
+		"Adding v4l2 controls from (%s) to (%s)\n",
+		state->v4l2_dev.name, dev->name);
+
+	v4l2_ctrl_add_handler(dev->ctrl_handler,
+		state->v4l2_dev.ctrl_handler, NULL, TRUE);
+
+	return v4l2_device_register_subdev_nodes(&state->v4l2_dev);
+}
+
 static int mipi_csis_parse_dt(struct platform_device *pdev,
 			    struct csi_state *state)
 {
@@ -986,6 +1020,7 @@ static const struct of_device_id mipi_csis_of_match[];
 
 static const struct v4l2_async_notifier_operations mxc_mipi_csi_subdev_ops = {
 	.bound = subdev_notifier_bound,
+	.complete = subdev_notifier_complete,
 };
 
 /* register parent dev */
@@ -1057,6 +1092,7 @@ static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
 		 CSIS_SUBDEV_NAME, state->index);
 	mipi_sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	mipi_sd->dev = &pdev->dev;
+	mipi_sd->ctrl_handler = &state->ctrl_handler;
 
 	state->csis_fmt = &mipi_csis_formats[0];
 	state->format.code = mipi_csis_formats[0].code;
@@ -1146,6 +1182,9 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	}
 	v4l2_info(&state->v4l2_dev, "mipi csi v4l2 device registered\n");
 
+	ret = v4l2_ctrl_handler_init(&state->ctrl_handler, NUM_CTRLS_HINT);
+	state->v4l2_dev.ctrl_handler = &state->ctrl_handler;
+
 	/* .. and a pointer to the subdev. */
 	platform_set_drvdata(pdev, state);
 
diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
index 7ac7a5063..f5c3d2d3d 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -768,6 +768,15 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:	return "Min Number of Output Buffers";
 	case V4L2_CID_ALPHA_COMPONENT:		return "Alpha Component";
 	case V4L2_CID_COLORFX_CBCR:		return "Color Effects, CbCr";
+	case V4L2_CID_FRAME_RATE:		return "Frame Rate";
+	case V4L2_CID_ROI_WIDTH:		return "ROI Width";
+	case V4L2_CID_ROI1_HEIGHT:		return "ROI 1 Height";
+	case V4L2_CID_ROI2_HEIGHT:		return "ROI 2 Height";
+	case V4L2_CID_ROI_OFFSET_COL:		return "ROI Offset Col";
+	case V4L2_CID_ROI1_OFFSET_ROW:		return "ROI 1 Offset Row";
+	case V4L2_CID_ROI2_OFFSET_ROW:		return "ROI 2 Offset Row";
+	case V4L2_CID_H_SUB_SAMPLING:		return "Horizontal Sub Sampling";
+	case V4L2_CID_V_SUB_SAMPLING:		return "Vertical Sub Sampling";
 
 	/* Codec controls */
 	/* The MPEG controls are applicable to all codec controls
@@ -1265,6 +1274,9 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 	case V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD:
 	case V4L2_CID_MPEG_VIDEO_HEVC_TIER:
 	case V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE:
+	case V4L2_CID_ANALOGUE_GAIN:
+	case V4L2_CID_H_SUB_SAMPLING:
+	case V4L2_CID_V_SUB_SAMPLING:
 		*type = V4L2_CTRL_TYPE_MENU;
 		break;
 	case V4L2_CID_LINK_FREQ:
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index a2669b79b..1172d29eb 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -143,8 +143,19 @@ enum v4l2_colorfx {
 #define V4L2_CID_ALPHA_COMPONENT		(V4L2_CID_BASE+41)
 #define V4L2_CID_COLORFX_CBCR			(V4L2_CID_BASE+42)
 
-/* last CID + 1 */
-#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+43)
+enum TOPAZ2M_CUSTOM_V4L2_CID {
+  V4L2_CID_FRAME_RATE = V4L2_CID_BASE+43,
+  V4L2_CID_ROI_WIDTH,
+  V4L2_CID_ROI1_HEIGHT,
+  V4L2_CID_ROI2_HEIGHT,
+  V4L2_CID_ROI_OFFSET_COL,
+  V4L2_CID_ROI1_OFFSET_ROW,
+  V4L2_CID_ROI2_OFFSET_ROW,
+  V4L2_CID_H_SUB_SAMPLING,
+  V4L2_CID_V_SUB_SAMPLING,
+  /* last CID + 1 */
+  V4L2_CID_LASTP1,
+};
 
 /* USER-class private control IDs */
 
-- 
2.25.1

